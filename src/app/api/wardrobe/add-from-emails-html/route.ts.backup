import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { log } from '@/lib/logger';
import { getEmailById, listEmails } from '@/lib/gmail-service';
import { Mistral } from '@mistralai/mistralai';
import { createHMPrompt, createMyntraPrompt } from '@/lib/email-extraction-prompts';
import { addItemsToWardrobe } from '@/lib/wardrobe-integration';
import { ExtractedItem } from '@/types/email-extraction';
import { extractZaraProductsFromHtml } from '@/lib/email-content-parser';
import { processItemImage } from '@/lib/image-utils';
import { extractHnMItems, extractMyntraItems } from '@/lib/email-item-extractor';
import { extractZaraItems } from '@/lib/email-item-extractor';
import fetch from 'node-fetch';

export async function POST(req: NextRequest) {
  try {
    // Check if the user is authenticated
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Parse the request body
    const body = await req.json();
    const { emailId, retailer, maxEmails } = body;

    if (!retailer) {
      return NextResponse.json({ error: 'Retailer is required' }, { status: 400 });
    }

    // Validate retailer
    const normalizedRetailer = retailer.trim().toLowerCase();
    if (!['h&m', 'myntra', 'zara'].includes(normalizedRetailer)) {
      return NextResponse.json(
        { error: 'Invalid retailer. Supported retailers: H&M, Myntra, Zara' },
        { status: 400 }
      );
    }

    // Determine if we're processing a single email or batch processing
    if (emailId) {
      // Single email processing
      return await processSingleEmail(session.user.id, emailId, normalizedRetailer);
    } else if (maxEmails) {
      // Batch processing of multiple emails
      return await processMultipleEmails(session.user.id, normalizedRetailer, maxEmails);
    } else {
      return NextResponse.json({ error: 'Either emailId or maxEmails parameter is required' }, { status: 400 });
    }
  } catch (error) {
    log('Error in add-from-emails-html API', { error });
    return NextResponse.json({
      error: 'Failed to extract items from email HTML',
      details: error instanceof Error ? error.message : String(error)
    }, { status: 500 });
  }
}

/**
 * Process a single email and extract items from it
 */
async function processSingleEmail(userId: string, emailId: string, retailer: string) {
  // Fetch the email HTML content
  log('Fetching email content via Gmail API', { emailId, retailer });
  const email = await getEmailById(userId, emailId);
  
  if (!email) {
    return NextResponse.json({ error: 'Failed to fetch email content' }, { status: 500 });
  }
  
  if (!email.body?.html) {
    return NextResponse.json({ error: 'No HTML content found in email' }, { status: 400 });
  }

  // Process the HTML content to extract items
  log('Processing HTML content with AI', { emailId });
  
  try {
    const items = await extractItemsFromHtml(
      email.body.html, 
      retailer
    );
    
    // Process each item to handle image extraction
    const processedItems = await Promise.all(items.map(async (item) => {
      if (!item.image) {
        console.warn('No image URL found for item:', item.name);
        return item; // Skip processing if no image URL
      }
      
      try {
        console.log(`Processing image for item: ${item.name}, URL: ${item.image}`);
        
        // Validate the image URL
        if (!item.image.startsWith('http')) {
          console.warn(`Invalid image URL for ${item.name}: ${item.image}`);
          return item;
        }
        
        const response = await fetch(item.image);
        if (!response.ok) {
          console.warn(`Failed to fetch image for ${item.name}: ${response.status} ${response.statusText}`);
          return item; // Return item without processed image
        }
        
        const imageBuffer = await response.buffer();
        console.log(`Successfully fetched image for ${item.name}, size: ${imageBuffer.length} bytes`);
        
        if (imageBuffer.length === 0) {
          console.warn(`Empty image buffer for ${item.name}`);
          return item;
        }
        
        const processedImageBuffer = await processItemImage(imageBuffer, item.name);
        
        // Validate the processed image
        if (processedImageBuffer.length === 0) {
          console.warn(`Empty processed image buffer for ${item.name}`);
          return item;
        }
        
        // Add the data URL prefix for proper rendering
        const processedImage = `data:image/jpeg;base64,${processedImageBuffer.toString('base64')}`;
        console.log(`Successfully processed image for ${item.name}, processed size: ${processedImageBuffer.length} bytes`);
        
        // For Zara items, also log the original image URL for debugging
        if (retailer.toLowerCase() === 'zara') {
          console.log(`Zara item "${item.name}" - Original URL: ${item.image}, Processed size: ${processedImageBuffer.length} bytes`);
        }
        
        return { ...item, image: processedImage };
      } catch (error) {
        console.error(`Error processing image for ${item.name}:`, error);
        return item; // Use original item if processing fails
      }
    }));
    
    // Add processed items to the user's wardrobe
    if (processedItems.length > 0) {
      log('Adding items to wardrobe', { count: processedItems.length, emailId });
      const wardrobeItems = processedItems.map(item => ({
        brand: item.brand,
        name: item.name,
        price: item.price || '',
        originalPrice: item.originalPrice || '',
        discount: item.discount || '',
        size: item.size || '',
        color: item.color || '',
        imageUrl: item.image,
        productLink: item.productLink || '',
        emailId,
        retailer,
        dominantColor: null,
        colorTag: item.color ? item.color.toLowerCase() : 'unknown'
      }));
      const result = await addItemsToWardrobe(
        userId,
        wardrobeItems
      );
      return NextResponse.json({
        success: true,
        message: `${result.addedItems} items added to wardrobe`,
        totalItemsFound: processedItems.length,
        itemsAdded: result.addedItems,
        items: result.addedWardrobeItems
      });
    } else {
      return NextResponse.json({
        success: false,
        message: '0 items detected in the email',
        totalItemsFound: 0,
        itemsAdded: 0,
        items: []
      });
    }
  } catch (error) {
    log('Error processing HTML content', { error, emailId });
    return NextResponse.json({
      error: 'Failed to process email HTML content',
      details: error instanceof Error ? error.message : String(error)
    }, { status: 500 });
  }
}

/**
 * Process multiple emails and extract items from them
 */
async function processMultipleEmails(userId: string, retailer: string, maxEmails: number) {
  log('Processing multiple emails', { retailer, maxEmails });
  
  // Create retailer-specific search query
  const orderConfirmationKeywords = [
    'order confirmation',
    'order confirmed',
    'order placed',
    'thank you for your order',
    'your order',
    'order number',
    'order receipt',
    'purchase confirmation',
    'receipt'
  ];
  
  const confirmationKeywordQuery = orderConfirmationKeywords
    .map(keyword => `subject:(${keyword})`)
    .join(' OR ');

  const searchQuery = retailer === 'myntra'
    ? `from:myntra.com subject:"Your Myntra order item has been shipped"`
    : retailer === 'zara'
    ? `from:noreply@zara.com subject:"Thank you for your purchase"`
    : `from:delivery.hm.com subject:"Order Confirmation"`;

  // Fetch emails
  const emailsResponse = await listEmails(userId, {
    q: searchQuery,
    maxResults: maxEmails,
  });
  
  if (!emailsResponse.messages || emailsResponse.messages.length === 0) {
    return NextResponse.json({
      success: false,
      message: 'No matching emails found',
      totalItemsFound: 0,
      itemsAdded: 0,
      items: []
    });
  }
  
  // Process each email one by one
  let totalItemsFound = 0;
  let totalItemsAdded = 0;
  const addedItems = [];
  const errors = [];
  
  for (const emailMessage of emailsResponse.messages) {
    try {
      const email = await getEmailById(userId, emailMessage.id);
      
      if (!email?.body?.html) {
        errors.push({ emailId: emailMessage.id, error: 'No HTML content found' });
        continue;
      }
      
      const items = await extractItemsFromHtml(email.body.html, retailer);
      totalItemsFound += items.length;
      
      if (items.length > 0) {
        const processedItems = await Promise.all(items.map(async (item) => {
          if (!item.image) {
            console.warn('No image URL found for item:', item.name);
            return item; // Skip processing if no image URL
          }
          try {
            const response = await fetch(item.image);
            const imageBuffer = await response.buffer();
            const processedImageBuffer = await processItemImage(imageBuffer, item.name);
            // Add the data URL prefix for proper rendering
            const processedImage = `data:image/jpeg;base64,${processedImageBuffer.toString('base64')}`;
            return { ...item, image: processedImage };
          } catch (error) {
            console.error('Error processing image:', error);
            return item;
          }
        }));
        const wardrobeItems = processedItems.map(item => ({
          brand: item.brand,
          name: item.name,
          price: item.price || '',
          originalPrice: item.originalPrice || '',
          discount: item.discount || '',
          size: item.size || '',
          color: item.color || '',
          imageUrl: item.image,
          productLink: item.productLink || '',
          emailId: emailMessage.id,
          retailer,
          dominantColor: null,
          colorTag: item.color ? item.color.toLowerCase() : 'unknown'
        }));
        const result = await addItemsToWardrobe(userId, wardrobeItems);
        totalItemsAdded += result.addedItems;
        addedItems.push(...result.addedWardrobeItems);
      }
    } catch (error) {
      log('Error processing email', { error, emailId: emailMessage.id });
      errors.push({ 
        emailId: emailMessage.id, 
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  
  return NextResponse.json({
    success: totalItemsAdded > 0,
    message: `${totalItemsAdded} items added to wardrobe from ${emailsResponse.messages.length} emails`,
    totalItemsFound,
    itemsAdded: totalItemsAdded,
    items: addedItems,
    processedEmails: emailsResponse.messages.length,
    errors: errors.length > 0 ? errors : undefined
  });
}

/**
 * Extract items directly from email HTML content using custom parsers
 */
export async function extractItemsFromHtml(
  htmlContent: string, 
  retailer: string
): Promise<ExtractedItem[]> {
  log('Extracting items from HTML content', { contentLength: htmlContent.length, retailer });
  
  // Step 1: Try custom parsers first
  let items: ExtractedItem[] = [];
  
  if (retailer.toLowerCase().includes('zara')) {
    log('Using custom Zara parser');
    const extractedProducts = extractZaraProductsFromHtml(htmlContent);
    items = extractedProducts.map(product => ({
      brand: 'Zara',
      name: product.name,
      price: product.price || '',
      originalPrice: product.originalPrice || '',
      discount: product.discount || '',
      size: product.size || '',
      color: product.color || '',
      imageUrl: product.images?.[0] || '',
      productLink: product.productLink || '',
      retailer: 'Zara',
      emailId: 'mock-email-id',
      orderId: undefined,
      reference: product.reference
    }));
  } else if (retailer.toLowerCase().includes('h&m')) {
    log('Using custom H&M parser');
    const mockEmail = {
      id: 'mock-email-id',
      threadId: 'mock-thread-id',
      labelIds: ['mock-label'],
      snippet: 'mock snippet',
      historyId: 'mock-history-id',
      internalDate: 'mock-date',
      sizeEstimate: 1000,
      from: 'mock@hm.com',
      to: 'mock@user.com',
      date: new Date(),
      subject: 'mock subject',
      body: { html: htmlContent }
    };
    const extractedItems = await extractHnMItems(mockEmail);
    items = extractedItems.map((item: any) => ({
      brand: item.brand,
      name: item.name,
      price: item.price,
      originalPrice: item.originalPrice,
      discount: item.discount,
      size: item.size,
      color: item.color,
      imageUrl: item.imageUrl,
      productLink: item.productLink,
      retailer: item.retailer,
      emailId: item.emailId,
      orderId: item.orderId,
      reference: item.reference
    }));
  } else if (retailer.toLowerCase() === 'myntra') {
    log('Using custom Myntra parser');
    const mockEmail = {
      id: 'mock-email-id',
      threadId: 'mock-thread-id',
      labelIds: ['mock-label'],
      snippet: 'mock snippet',
      historyId: 'mock-history-id',
      internalDate: 'mock-date',
      sizeEstimate: 1000,
      from: 'mock@myntra.com',
      to: 'mock@user.com',
      date: new Date(),
      subject: 'mock subject',
      body: { html: htmlContent }
    };
    const extractedItems = await extractMyntraItems(mockEmail);
    items = extractedItems.map((item: any) => ({
      brand: item.brand,
      name: item.name,
      price: item.price,
      originalPrice: item.originalPrice,
      discount: item.discount,
      size: item.size,
      color: item.color,
      imageUrl: item.imageUrl,
      productLink: item.productLink,
      retailer: item.retailer,
      emailId: item.emailId,
      orderId: item.orderId,
      reference: item.reference
    }));
  }
  
  log('Custom parser results', { itemCount: items.length, retailer });
  
  // Step 2: Use Mistral AI to validate and enhance results
  const apiKey = process.env.MISTRAL_API_KEY;
  if (apiKey) {
    try {
      log('Using Mistral AI to validate and enhance results');
      const client = new Mistral({ apiKey });
      
      // Prepare the text content for AI analysis
      const textContent = extractTextFromHtml(htmlContent);
      
      // Create a prompt that includes the custom parser results
      const customResults = items.map(item => 
        `- ${item.name} (${item.brand || retailer}) - ${item.price || 'Price not found'} - Size: ${item.size || 'Unknown'} - Color: ${item.color || 'Unknown'}`
      ).join('\n');
      
      const prompt = `I'm analyzing an email from ${retailer} to extract clothing items. 

Here are the items I found using custom parsing:
${customResults || 'No items found with custom parser'}

Please validate and enhance these results. Look for any missing items, correct any errors, and provide additional details if possible.

Email content:
${textContent.substring(0, 4000)}

Please respond with a JSON array of clothing items in this exact format:
[
  {
    "brand": "string",
    "name": "string", 
    "price": "string (with currency symbol)",
    "originalPrice": "string (with currency symbol)",
    "discount": "string (e.g., '20% OFF')",
    "size": "string",
    "color": "string",
    "imageUrl": "string (URL)",
    "productLink": "string (URL)",
    "retailer": "${retailer}",
    "orderId": "string",
    "reference": "string"
  }
]

Only include items that are actually clothing products. If no items are found, return an empty array [].`;

      const response = await client.chat({
        model: 'mistral-large-latest',
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.1,
        maxTokens: 2000
      });

      const aiResponse = response.choices[0]?.message?.content;
      log('Mistral AI response received', { responseLength: aiResponse?.length });
      
      if (aiResponse) {
        try {
          // Try to extract JSON from the response
          const jsonMatch = aiResponse.match(/\[[\s\S]*\]/);
          if (jsonMatch) {
            const aiItems = JSON.parse(jsonMatch[0]) as ExtractedItem[];
            log('AI extracted items', { aiItemCount: aiItems.length });
            
            // Merge and deduplicate results
            const mergedItems = mergeAndDeduplicateItems(items, aiItems);
            log('Merged results', { finalItemCount: mergedItems.length });
            
            return mergedItems;
          }
        } catch (parseError) {
          log('Failed to parse AI response as JSON', { error: parseError, response: aiResponse });
        }
      }
    } catch (aiError) {
      log('Mistral AI processing failed', { error: aiError });
    }
  } else {
    log('Mistral API key not found, using only custom parser results');
  }
  
  // Return custom parser results if AI enhancement failed or not available
  return items;
}

/**
 * Merge and deduplicate items from custom parser and AI
 */
function mergeAndDeduplicateItems(customItems: ExtractedItem[], aiItems: ExtractedItem[]): ExtractedItem[] {
  const merged = [...customItems];
  
  for (const aiItem of aiItems) {
    // Check if this AI item is already covered by a custom item
    const isDuplicate = customItems.some(customItem => 
      customItem.name.toLowerCase().includes(aiItem.name.toLowerCase()) ||
      aiItem.name.toLowerCase().includes(customItem.name.toLowerCase()) ||
      (customItem.productLink && aiItem.productLink && customItem.productLink === aiItem.productLink)
    );
    
    if (!isDuplicate) {
      merged.push(aiItem);
    }
  }
  
  return merged;
}

/**
 * Fallback function to extract items from text when AI processing is not available
 */
function extractItemsFromTextFallback(textContent: string, retailer: string): ExtractedItem[] {
  log('Using fallback text extraction', { retailer });
  
  const items: ExtractedItem[] = [];
  
  try {
    // Basic regex patterns to extract product information
    const productPatterns = [
      // Pattern for product names (look for common clothing terms)
      /(?:product|item|style)[:\s]*([^,\n\r]+(?:shirt|pant|dress|jacket|hoodie|sweater|jean|top|blouse|skirt|shorts|coat|blazer)[^,\n\r]*)/gi,
      // Pattern for prices
      /(?:price|cost)[:\s]*(\$?\d+(?:\.\d{2})?)/gi,
      // Pattern for sizes
      /(?:size)[:\s]*([A-Z]+(?:\d+)?)/gi,
      // Pattern for colors
      /(?:color|colour)[:\s]*([A-Za-z\s]+)/gi
    ];
    
    // Extract basic information
    const productMatches = textContent.match(productPatterns[0]) || [];
    const priceMatches = textContent.match(productPatterns[1]) || [];
    const sizeMatches = textContent.match(productPatterns[2]) || [];
    const colorMatches = textContent.match(productPatterns[3]) || [];
    
    // Create basic items from extracted information
    if (productMatches.length > 0) {
      for (let i = 0; i < productMatches.length; i++) {
        const productName = productMatches[i].replace(/^(?:product|item|style)[:\s]*/i, '').trim();
        
        if (productName && productName.length > 3) {
          items.push({
            brand: retailer === 'myntra' ? 'Myntra' : retailer === 'h&m' ? 'H&M' : 'Unknown Brand',
            name: productName,
            price: priceMatches[i] || '',
            originalPrice: '',
            discount: '',
            size: sizeMatches[i] || '',
            color: colorMatches[i] || '',
            image: '', // No image in fallback
            productLink: '',
            myntraLink: '',
            sourceRetailer: retailer
          });
        }
      }
    }
    
    // If no structured data found, try to extract any clothing-related terms
    if (items.length === 0) {
      const clothingTerms = textContent.match(/\b(shirt|pant|dress|jacket|hoodie|sweater|jean|top|blouse|skirt|shorts|coat|blazer|overshirt|t-shirt|tshirt)\b/gi);
      
      if (clothingTerms) {
        const uniqueTerms = [...new Set(clothingTerms)];
        uniqueTerms.forEach(term => {
          items.push({
            brand: retailer === 'myntra' ? 'Myntra' : retailer === 'h&m' ? 'H&M' : 'Unknown Brand',
            name: `${term.charAt(0).toUpperCase() + term.slice(1).toLowerCase()} (${retailer})`,
            price: '',
            originalPrice: '',
            discount: '',
            size: '',
            color: '',
            image: '',
            productLink: '',
            myntraLink: '',
            sourceRetailer: retailer
          });
        });
      }
    }
    
    log('Fallback extraction completed', { itemsFound: items.length });
    return items;
  } catch (error) {
    log('Error in fallback extraction', { error });
    return [];
  }
}

/**
 * Decode HTML entities in a string
 */
function decodeHtmlEntities(text: string): string {
  if (!text) return '';
  
  return text
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'")
    .replace(/&#x2F;/g, '/')
    .replace(/&#x3D;/g, '=')
    .replace(/&#x3B;/g, ';');
}

/**
 * Extract readable text from HTML content while preserving image URLs
 */
function extractTextFromHtml(html: string): string {
  try {
    // First, let's extract all image URLs for reference
    const imgRegex = /<img[^>]+src=["']([^"']+)["']/g;
    const images: string[] = [];
    let match;
    
    while ((match = imgRegex.exec(html)) !== null) {
      if (match[1]) {
        // Skip tiny images, spacers, and icons (often smaller than 100 characters in URL)
        if (match[1].length > 100 || match[1].includes('product') || 
            match[1].includes('myntra') || match[1].includes('hm.com')) {
          // Decode HTML entities in image URLs
          const decodedUrl = decodeHtmlEntities(match[1]);
          images.push(`IMAGE_URL: ${decodedUrl}`);
        }
      }
    }
    
    // Also extract background images
    const bgRegex = /background-image\s*:\s*url\s*\(\s*['"]?([^'")]+)/g;
    while ((match = bgRegex.exec(html)) !== null) {
      if (match[1] && (match[1].length > 100 || match[1].includes('product') || 
                       match[1].includes('myntra') || match[1].includes('hm.com'))) {
        // Decode HTML entities in background image URLs
        const decodedUrl = decodeHtmlEntities(match[1]);
        images.push(`BACKGROUND_IMAGE_URL: ${decodedUrl}`);
      }
    }
    
    // Try to extract image URLs from anchor tags pointing to product images
    const aTagRegex = /<a[^>]+href=["']([^"']+\.(?:jpg|jpeg|png|gif|webp)[^"']*)["'][^>]*>/gi;
    while ((match = aTagRegex.exec(html)) !== null) {
      if (match[1] && (match[1].includes('product') || match[1].includes('myntra') || 
                       match[1].includes('hm.com'))) {
        // Decode HTML entities in linked image URLs
        const decodedUrl = decodeHtmlEntities(match[1]);
        images.push(`LINKED_IMAGE_URL: ${decodedUrl}`);
      }
    }
    
    // Convert HTML to text
    let text = html
      .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '') // Remove style tags and their content
      .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '') // Remove script tags and their content
      .replace(/<[^>]+>/g, '\n') // Replace tags with newlines
      .replace(/&nbsp;/g, ' ') // Replace non-breaking spaces
      .replace(/&amp;/g, '&') // Replace ampersands
      .replace(/&lt;/g, '<') // Replace less than
      .replace(/&gt;/g, '>') // Replace greater than
      .replace(/&quot;/g, '"') // Replace quotes
      .replace(/&#39;/g, "'") // Replace apostrophes
      .replace(/\n{2,}/g, '\n\n') // Replace multiple newlines with just two
      .trim();
    
    // Append extracted image URLs to the text
    if (images.length > 0) {
      text += '\n\n--- EXTRACTED IMAGE URLS ---\n';
      text += images.join('\n');
    }
    
    log('Extracted text from HTML', { 
      textLength: text.length, 
      imageCount: images.length 
    });
    
    return text;
  } catch (error) {
    log('Error extracting text from HTML', { error });
    return html; // Return the original HTML if extraction fails
  }
} 